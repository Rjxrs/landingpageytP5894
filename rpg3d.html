<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mine RPG 2D</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            overflow: hidden;
            background-color: #111827;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #gameCanvas {
            border: 2px solid #374151;
            border-radius: 8px;
            background-color: #1f2937;
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        .ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1;
            color: #ffffff;
            padding: 10px;
        }
        .xp-bar {
            width: 200px;
            height: 16px;
            background-color: #4a5568;
            border-radius: 8px;
            margin-top: 5px;
            position: relative;
            overflow: hidden;
        }
        .xp-bar-fill {
            height: 100%;
            background-color: #84cc16;
            border-radius: 8px;
            width: 0;
            transition: width 0.3s ease;
        }
        .level-display {
            font-size: 0.8rem;
            color: #ffffff;
        }
        #inventory {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background-color: rgba(243, 244, 246, 0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: none;
            max-height: 80vh;
            overflow-y: auto;
            width: 250px;
        }
        #inventory h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #1f2937;
            text-align: center;
        }
        #inventory ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #inventory li {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #374151;
        }
        #inventory li:last-child {
            border-bottom: none;
        }
        #inventory li span:first-child {
             margin-right: auto;
        }
        .item-name {
            font-weight: 500;
        }
        #inventory-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            padding: 8px 16px;
            background-color: #4CAF20;
            color: #FFFFFF;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #inventory-toggle:hover {
            background-color: #45a01a;
        }
        #quests {
            position: absolute;
            top: 100px;
            left: 10px;
            z-index: 1;
            background-color: rgba(243, 244, 246, 0.8);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            max-height: 60vh;
            overflow-y: auto;
            width: 300px;
            display: none;
        }
        #quests h2 {
            font-size: 1.2rem;
            margin-bottom: 10px;
            color: #1f2937;
            text-align: center;
        }
        #quests ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #quests li {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            color: #374151;
            font-size: 0.9rem;
        }
        #quests li:last-child {
            border-bottom: none;
        }
        #quests li strong {
            font-weight: 600;
            color: #1f2937;
        }
        #quests li.completed {
            color: #6b7280;
            font-style: italic;
        }
        #quest-toggle {
            position: absolute;
            top: 55px;
            right: 10px;
            z-index: 1;
            padding: 8px 16px;
            background-color: #8b5cf6;
            color: #FFFFFF;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #quest-toggle:hover {
            background-color: #7c3aed;
        }
        #message-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(55, 65, 81, 0.9);
            color: #ffffff;
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
            font-size: 0.9rem;
            text-align: center;
            min-width: 200px;
            max-width: 400px;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        #message-box.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        #message-box.hide {
            opacity: 0;
            transform: translateX(-50%) translateY(20px);
        }
        .game-over-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            display: none;
        }
        .game-over-content {
            text-align: center;
            padding: 20px;
            border-radius: 8px;
            border: 4px solid #dc2626;
            background-color: #fee2e2;
        }
        .game-over-title {
            font-size: 2rem;
            color: #b91c1c;
            margin-bottom: 1rem;
        }
        .game-over-message {
            font-size: 1.25rem;
            color: #374151;
            margin-bottom: 1.5rem;
        }
        .menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(243, 244, 246, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 2;
            text-align: center;
            width: 80%;
            max-width: 400px;
        }
        .menu-container h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        .menu-container button {
            padding: 0.75rem 1.5rem;
            background-color: #4CAF20;
            color: #FFFFFF;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.3s ease;
            margin: 0.5rem;
            width: 100%;
        }
        .menu-container button:hover {
            background-color: #45a01a;
        }
        .menu-container .input-group {
            margin-bottom: 1rem;
            text-align: left;
        }
        .menu-container .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #1f2937;
            font-size: 0.8rem;
        }
        .menu-container .input-group input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        #char-creation {
            display: none;
        }
        #class-selection {
            display: none;
        }
        .skill-selection-container {
            display: none;
            max-height: 70vh;
            overflow-y: auto;
            text-align: left;
        }
        .skill-selection-container h3 {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: #1f2937;
            text-align: center;
        }
        .skill-selection-container ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .skill-selection-container li {
            padding: 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            color: #374151;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .skill-selection-container li:last-child {
            border-bottom: none;
        }
        .skill-selection-container li span {
            margin-right: auto;
        }
        .skill-selection-container li button {
            padding: 0.25rem 0.5rem;
            background-color: #8b5cf6;
            color: #FFFFFF;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.7rem;
            transition: background-color 0.3s ease;
        }
        .skill-selection-container li button:hover {
            background-color: #7c3aed;
        }
        .skill-selection-container li button.selected {
            background-color: #16a34a;
        }
        .hud-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .health-bar {
            width: 200px;
            height: 16px;
            background-color: #4a5568;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background-color: #84cc16;
            border-radius: 8px;
            width: 100%;
            transition: width 0.3s ease;
        }

        .mana-bar {
            width: 200px;
            height: 16px;
            background-color: #4a5568;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .mana-bar-fill {
            height: 100%;
            background-color: #3b82f6;
            border-radius: 8px;
            width: 100%;
            transition: width 0.3s ease;
        }

        .hud-text {
            font-size: 0.8rem;
            color: #ffffff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-container">
        <div class="level-display">Level: <span id="level">1</span></div>
        <div class="xp-bar">
            <div class="xp-bar-fill" id="xp-bar-fill"></div>
        </div>
        <div>Gold: <span id="gold">0</span></div>
    </div>
    <div class="hud-container">  
        <div class="health-bar">
            <div class="health-bar-fill" id="health-bar-fill"></div>
        </div>
        <span class="hud-text">HP: <span id="hp-text">100</span></span>
        <div class="mana-bar">
            <div class="mana-bar-fill" id="mana-bar-fill"></div>
        </div>
        <span class="hud-text">Mana: <span id="mana-text">100</span></span>
    </div>
    <button id="inventory-toggle">Inventory</button>
    <div id="inventory">
        <h2>Inventory</h2>
        <ul>
            </ul>
    </div>
    <button id="quest-toggle">Quests</button>
    <div id="quests">
        <h2>Quests</h2>
        <ul>
            </ul>
    </div>
    <div id="message-box" class="message-box hide"></div>
    <div class="game-over-overlay">
        <div class="game-over-content">
            <h2 class="game-over-title">Game Over</h2>
            <p class="game-over-message">You have died.  Game Over.</p>
        </div>
    </div>

    <div id="menu" class="menu-container">
        <h2>Welcome to Mine RPG</h2>
        <button id="start-game">Start New Game</button>
        <button id="load-game">Load Game</button>
    </div>

    <div id="char-creation" class="menu-container">
        <h2>Character Creation</h2>
        <div class="input-group">
            <label for="char-name">Name:</label>
            <input type="text" id="char-name" placeholder="Enter your name">
        </div>
        <button id="select-class">Select Class</button>
    </div>

    <div id="class-selection" class="menu-container">
        <h2>Class Selection</h2>
        <button data-class="warrior">Warrior</button>
    </div>

    <div id="skill-selection" class="skill-selection-container">
        <h3>Select Skills (5 Max)</h3>
        <ul>
        </ul>
        <button id="finish-skills">Finish Selection</button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const menuContainer = document.getElementById('menu');
        const startGameButton = document.getElementById('start-game');
        const loadGameButton = document.getElementById('load-game');
        const charCreationScreen = document.getElementById('char-creation');
        const charNameInput = document.getElementById('char-name');
        const selectClassButton = document.getElementById('select-class');
        const classSelectionScreen = document.getElementById('class-selection');
        const skillSelectionScreen = document.getElementById('skill-selection');
        const skillList = skillSelectionScreen.querySelector('ul');
        const finishSkillsButton = document.getElementById('finish-skills');
        const inventoryDiv = document.getElementById('inventory');
        const inventoryList = inventoryDiv.querySelector('ul');
        const inventoryToggle = document.getElementById('inventory-toggle');
        const questsDiv = document.getElementById('quests');
        const questsList = questsDiv.querySelector('ul');
        const questToggle = document.getElementById('quest-toggle');
        const messageBox = document.getElementById('message-box');
        const gameOverOverlay = document.querySelector('.game-over-overlay');

        // Get references to the new HUD elements
        const healthBarFill = document.getElementById('health-bar-fill');
        const hpText = document.getElementById('hp-text');
        const manaBarFill = document.getElementById('mana-bar-fill');
        const manaText = document.getElementById('mana-text');


        let gameRunning = false;
        let player = null;
        let selectedClass = null;
        let selectedSkills = [];
        let skillPoints = 5;
        let npcs = [];
        let currentDialog = null;
        let gameInitialized = false; //track game initialization

        // Set the canvas dimensions
        const canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const worldSize = 64;
        let tileSize = canvasSize / worldSize;


        const classes = {
            warrior: {
                name: 'Warrior',
                description: 'A strong fighter with high health.',
                stats: { strength: 12, dexterity: 7, vitality: 18, intelligence: 5, wisdom: 5 },
                skills: ['Swordsmanship', 'Blocking', 'Heavy Armor', 'Athletics', 'Intimidation'],
            },
        };

        const allSkills = {
            Swordsmanship: { name: 'Swordsmanship', description: 'Increases damage with swords.', type: 'combat' },
            Blocking: { name: 'Blocking', description: 'Reduces damage taken when blocking.', type: 'combat' },
            "Heavy Armor": { name: "Heavy Armor", description: "Increases defense with heavy armor.", type: "combat" },
            Athletics: { name: 'Athletics', description: 'Increases stamina and movement speed.', type: 'general' },
            Intimidation: { name: 'Intimidation', description: 'Improves chances to scare enemies.', type: 'social' },
            "Fire Magic": { name: "Fire Magic", description: "Increases fire spell damage.", type: 'magic' },
            "Ice Magic": { name: "Ice Magic", description: "Increases ice spell damage and slows enemies.", type: 'magic' },
            "Lightning Magic": { name: "Lightning Magic", description: "Increases lightning spell damage and chance to stun.", type: 'magic' },
            "Arcane Magic": { name: 'Arcane Magic', description: 'Increases damage and reduces mana cost of arcane spells.', type: 'magic' },
            Meditation: { name: 'Meditation', description: 'Increases mana regeneration rate.', type: 'magic' },
            Archery: { name: 'Archery', description: 'Increases damage with bows.', type: 'combat' },
            Marksmanship: { name: 'Marksmanship', description: 'Increases accuracy with ranged weapons.', type: 'combat' },
            Acrobatics: { name: 'Acrobatics', description: 'Increases evasion and movement speed.', type: 'general' },
            Stealth: { name: 'Stealth', description: 'Increases ability to remain hidden.', type: 'general' },
            Survival: { name: 'Survival', description: 'Increases ability to find resources in the wild.', type: 'general' },
            "Dagger Mastery": { name: "Dagger Mastery", description: "Increases damage and attack speed with daggers.", type: "combat" },
            Sneaking: { name: 'Sneaking', description: 'Improves ability to move silently.', type: 'general' },
            Lockpicking: { name: 'Lockpicking', description: 'Increases ability to open locked doors and chests.', type: 'general' },
            Pickpocketing: { name: 'Pickpocketing', description: 'Increases ability to steal items.', type: 'general' },
        };

        const initPlayer = () => {
            player = {
                x: canvasSize / 2,
                y: canvasSize / 2,
                size: 10,
                level: 1,
                xp: 0,
                gold: 100,
                inventory: {
                    pickaxe: { name: 'Pickaxe', quantity: 1, level: 1 },
                    torch: { name: 'Torch', quantity: 5 },
                    healthPotion: { name: 'Health Potion', quantity: 3 },
                    "Iron Ore": { name: "Iron Ore", quantity: 0 },
                    "Copper Ore": { name: "Copper Ore", quantity: 0 },
                    "Silver Ore": { name: "Silver Ore", quantity: 0 },
                    "Gold Ore": { name: "Gold Ore", quantity: 0 },
                },
                health: 100,
                maxHealth: 100,
                damage: 15,
                attackSpeed: 1,
                attackRange: tileSize,
                isMining: false,
                miningTarget: null,
                miningProgress: 0,
                weapon: null,
                armor: null,
                direction: 0,
                class: selectedClass,
                skills: selectedSkills,
                stats: {
                    strength: classes[selectedClass].stats.strength,
                    dexterity: classes[selectedClass].stats.dexterity,
                    vitality: classes[selectedClass].stats.vitality,
                    intelligence: classes[selectedClass].stats.intelligence,
                    wisdom: classes[selectedClass].stats.wisdom,
                },
                mana: 100,
                maxMana: 100,
                currentAction: 'idle',
                target: null,
                name: charNameInput.value,
            };
            gameInitialized = true;
        };

        const levelCaps = [];
        for (let i = 1; i <= 99; i++) {
            levelCaps.push(i * 100);
        }

        const getLevelCap = (level) => {
            if (level <= 99) {
                return levelCaps[level - 1];
            }
            return Infinity;
        };

        const updateLevel = () => {
            if (!player) return;
            const levelDisplay = document.getElementById('level');
            const xpBarFill = document.getElementById('xp-bar-fill');
            const prevLevel = player.level;
            while (player.xp >= getLevelCap(player.level) && player.level < 99) {
                player.level++;
                player.damage += 7;
                player.maxHealth += 15;
                player.health = player.maxHealth;
                player.maxMana += 10;
                player.mana = player.maxMana;
                showMessage(`Leveled up to level ${player.level}!`);
            }
            if (player && player.level > prevLevel) {
                showMessage(`Leveled up to level ${player.level}!`);
            }
            levelDisplay.textContent = player.level;
            const levelCap = getLevelCap(player.level);
            const xpPercentage = Math.min(100, (player.xp / levelCap) * 100);
            xpBarFill.style.width = `${xpPercentage}%`;
        };

        function updateInventoryDisplay() {
            if (!player) return;
            inventoryList.innerHTML = '';
            for (const [itemKey, item] of Object.entries(player.inventory)) {
                const li = document.createElement('li');
                const itemNameSpan = document.createElement('span');
                itemNameSpan.className = 'item-name';
                itemNameSpan.textContent = item.name;

                const quantitySpan = document.createElement('span');
                quantitySpan.textContent = `x${item.quantity}`;

                li.appendChild(itemNameSpan);
                li.appendChild(quantitySpan);

                if (item.level) {
                    const equipButton = document.createElement('button');
                    equipButton.textContent = 'Equip';
                    equipButton.className = "bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded";
                    equipButton.addEventListener('click', () => {
                        equipItem(itemKey);
                    });
                    li.appendChild(equipButton);
                }
                inventoryList.appendChild(li);
            }
        }

        function equipItem(itemKey) {
            if (!player) return;
            const item = player.inventory[itemKey];
            if (!item) return;

            if (item.level) {
                if (item.name.includes('Pickaxe')) {
                    player.weapon = item;
                    showMessage(`Equipped ${item.name}!`);
                }
            }
            updateInventoryDisplay();
        }

        const questData = [
            {
                id: 'quest1',
                title: 'Gather Iron Ore',
                description: 'Collect 30 Iron Ore.',
                objective: { type: 'collect', item: 'Iron Ore', quantity: 30 },
                reward: { type: 'xp', amount: 300 },
                completed: false,
            },
            {
                id: 'quest2',
                title: 'Clear the Forest',
                description: 'Defeat 10 Goblins.',
                objective: { type: 'kill', monster: 'goblin', quantity: 10 },
                reward: { type: 'xp', amount: 250 },
                completed: false,
            },
            {
                id: 'quest3',
                title: "Find the Lost Artifact",
                description: "Find the artifact hidden in the Abandoned Tower.",
                objective: { type: "find", artifact: "Lost Artifact" },
                reward: { type: "gold", amount: 750 },
                completed: false,
            },
        ];

        let activeQuests = [];

        function updateQuestsDisplay() {
            if (!player) return;
            questsList.innerHTML = '';
            activeQuests.forEach(quest => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${quest.title}</strong><br>${quest.description}<br>Progress: `;
                if (quest.objective.type === 'collect') {
                    li.innerHTML += `${player.inventory[quest.objective.item]?.quantity || 0}/${quest.objective.quantity} ${quest.objective.item}`;
                } else if (quest.objective.type === 'kill') {
                    li.innerHTML += `${quest.killed}/${quest.objective.quantity} ${quest.objective.monster}s`;
                } else if (quest.objective.type === 'find') {
                    li.innerHTML += quest.found ? 'Found' : 'Not Found';
                }

                if (quest.completed) {
                    li.classList.add('completed');
                    li.innerHTML += '<br>Completed!';
                }
                questsList.appendChild(li);
            });
        }

        function startQuest(questId) {
            const quest = questData.find(q => q.id === questId);
            if (quest && !activeQuests.includes(quest)) {
                activeQuests.push(quest);
                showMessage(`Quest "${quest.title}" started!`);
                updateQuestsDisplay();
                 if (quest.objective.type === 'kill') {
                    quest.killed = 0;
                } else if (quest.objective.type === 'find') {
                    quest.found = false;
                }
            }
        }

        function checkQuestCompletion(quest) {
            if (!player) return;
            if (quest.completed) return;
            let completed = false;
            if (quest.objective.type === 'collect') {
                const collectedQuantity = player.inventory[quest.objective.item]?.quantity || 0;
                completed = collectedQuantity >= quest.objective.quantity;
            } else if (quest.objective.type === 'kill') {
                completed = quest.killed >= quest.objective.quantity;
            } else if (quest.objective.type === 'find') {
                completed = quest.found;
            }

            if (completed) {
                quest.completed = true;
                if (quest.reward.type === 'xp') {
                    player.xp += quest.reward.amount;
                    updateLevel();
                    showMessage(`Quest "${quest.title}" completed!  Received ${quest.reward.amount} XP.`);
                } else if (quest.reward.type === 'gold') {
                    player.gold += quest.reward.amount;
                    document.getElementById('gold').textContent = player.gold;
                    showMessage(`Quest "${quest.title}" completed!  Received ${quest.reward.amount} Gold.`);
                }
                updateQuestsDisplay();
            }
        }

        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.classList.remove('hide');
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
                messageBox.classList.add('hide');
            }, 3000);
        }

        // World generation
        const tileMap = {};
        const TILE_SIZE = 32;

        function generateWorld() {
            for (let x = 0; x < worldSize; x++) {
                for (let y = 0; y < worldSize; y++) {
                    let tileType = 'grass';
                    if (x > 10 && x < 30 && y > 10 && y < 30) {
                        tileType = 'stone';
                    }  else if (x > 40 && x < 50 && y > 40 && y < 50){
                        tileType = 'water';
                    }
                    else if (Math.random() < 0.2) {
                        tileType = 'tree';
                    }
                    tileMap[`${x},${y}`] = { type: tileType, mined: false, hardness: 100 };
                }
            }
            // Add a house
            createBuilding(5, 5, 4, 4, 'house');
            //add a tower
            createBuilding(15,15, 3,5, 'tower')
            //create path
            createPath(0,0,10,0);
            createPath(10,0,10,10);
            //add npcs
            spawnNpc(8, 8, 'villager');
            spawnNpc(20, 20, 'merchant');
        }

        function createPath(startX, startY, endX, endY){
            let x = startX;
            let y = startY;
            while(x !== endX || y !== endY){
                if(x < endX){
                    x++;
                } else if (x > endX){
                    x--;
                } else if (y < endY){
                    y++;
                } else if (y > endY){
                    y--;
                }
                tileMap[`${x},${y}`] = { type: 'path', mined: false, hardness: 100 };
            }

        }

        function createBuilding(x, y, width, height, type) {
            for (let i = 0; i < width; i++) {
                for (let j = 0; j < height; j++) {
                    tileMap[`${x + i},${y + j}`] = { type: type, mined: false, hardness: 100 };
                }
            }
        }

        function getTile(x, y) {
            const tile = tileMap[`${x},${y}`];
            if (!tile) {
                return { type: 'grass', mined: true, hardness: 100 };
            }
            return tile;
        }

        function mineTile(x, y) {
            if (!player.isMining) {
                player.isMining = true;
                player.miningTarget = { x, y };
                player.miningProgress = 0;
            }
        }

        const tileImages = {
            'grass': new Image(),
            'stone': new Image(),
            'tree': new Image(),
            'house': new Image(),
            'tower': new Image(),
            'path': new Image(),
            'water': new Image(),
        };

        tileImages['grass'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['stone'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['tree'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['house'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['tower'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['path'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';
        tileImages['water'].src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABjMvFQAAAABmJLR0QA/wzLwKQAAAAlwSFlzAAALEwAACxMBAjZJmAAAAAd0lEQVRYw+2XwQkAIADAyM/9B4nVgYkKxKCIlhjO4e+8KZuKCJjyxKkAAAAASUVORK5CYII=';


        function drawTile(x, y, tileType, mined) {
            const drawX = x * tileSize;
            const drawY = y * tileSize;

            if (mined) {
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(drawX, drawY, tileSize, tileSize);
            } else {
                let img = tileImages[tileType];
                if(img){
                     ctx.drawImage(img, drawX, drawY, tileSize, tileSize);
                }
                else{
                    ctx.fillStyle = '#6b7280';
                    ctx.fillRect(drawX, drawY, tileSize, tileSize);
                }
            }
        }

        function drawWorld() {
            for (let x = 0; x < worldSize; x++) {
                for (let y = 0; y < worldSize; y++) {
                    const tile = getTile(x, y);
                    drawTile(x, y, tile.type, tile.mined);
                }
            }
        }

        // Simple AABB collision detection
        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 &&
                x1 + w1 > x2 &&
                y1 < y2 + h2 &&
                y1 + h1 > y2;
        }

        // Monster stuff
        let monsters = [];
        let nextMonsterId = 0;

        function spawnMonster(x, y, type = 'goblin') {
            let health = 20;
            let damage = 5;
            let speed = 0.7;
            let size = 24;
            if (type === 'goblin') {
                health = 20;
                damage = 5;
                speed = 0.7;
                size = 24;
            } else if (type === 'orc') {
                health = 50;
                damage = 10;
                speed = 0.5;
                size = 32;
            }  else if (type === 'skeleton'){
                health = 30;
                damage = 8;
                speed = 0.6;
                size = 20;
            }

            const monster = {
                id: nextMonsterId++,
                x: x,
                y: y,
                type: type,
                health: health,
                maxHealth: health,
                damage: damage,
                speed: speed,
                size: size,
                color: type === 'goblin' ? '#16a34a' : type === 'orc' ? '#78350f' : '#e2e8f0',
                dead: false,
                attackCooldown: 0,
                attackSpeed: 1,
                attackRange: tileSize,
            };
            monsters.push(monster);
        }

        function drawMonster(monster) {
            if (monster.dead) return;
            ctx.fillStyle = monster.color;
            ctx.fillRect(monster.x - monster.size / 2, monster.y - monster.size / 2, monster.size, monster.size);
            ctx.fillStyle = '#ef4444';
            ctx.fillRect(monster.x - monster.size / 2, monster.y - monster.size - 5, monster.size * (monster.health / monster.maxHealth), 3);
        }

        function moveMonster(monster) {
            if (monster.dead) return;

            const dx = player.x - monster.x;
            const dy = player.y - monster.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 1) {
                monster.x += (dx / distance) * monster.speed;
                monster.y += (dy / distance) * monster.speed;
            }
        }

        function attackTarget(attacker, target) {
            if (!target) return;

            if (target.health !== undefined) {
                target.health -= attacker.damage;
                showMessage(`${attacker.name} attacks ${target.type} for ${attacker.damage} damage!`);
                 if (target.health <= 0) {
                    if (target.type === 'monster') {
                        damageMonster(target, attacker.damage);
                    } else {
                        target.dead = true;
                        target.health = 0;
                        showMessage(`${target.name} dies!`);
                    }

                }
                updateHealthBar();
            }
        }

        function monsterAttack(monster) {
            if (monster.dead) return;
            if (monster.attackCooldown > 0) return;

            const dx = player.x - monster.x;
            const dy = player.y - monster.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < monster.attackRange) {
                attackTarget(monster, player);
                monster.attackCooldown = 1 / monster.attackSpeed;
                updateHealthBar();
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }

        function handleMonsterAttackCooldown(monster) {
            if (monster.attackCooldown > 0) {
                monster.attackCooldown -= deltaTime;
            }
        }

        function checkMonsterCollision(monster) {
            if (monster.dead) return false;
            return checkCollision(
                player.x - player.size / 2,
                player.y - player.size / 2,
                player.size,
                player.size,
                monster.x - monster.size / 2,
                monster.y - monster.size / 2,
                monster.size,
                monster.size
            );
        }

        function damageMonster(monster, damage) {
            if (monster.dead) return;
            monster.health -= damage;
            if (monster.health <= 0) {
                monster.dead = true;
                player.xp += 20;
                player.gold += 10;
                updateLevel();
                document.getElementById('gold').textContent = player.gold;
                showMessage(`Killed a ${monster.type}!`);
                 if (quest.objective.type === 'kill' && quest.monster === monster.type) {
                    quest.killed++;
                }
            }
        }

        // Get the game over overlay

        // Function to show the game over screen
        function gameOver() {
            gameOverOverlay.style.display = 'flex';
            gameRunning = false;
        }

        // Event listener for restarting the game
        gameOverOverlay.addEventListener('click', () => {
            window.location.reload();
        });

        let keys = {};

        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        window.addEventListener('resize', () => {
            const newSize = Math.min(window.innerWidth, window.innerHeight) * 0.8;
            canvas.width = newSize;
            canvas.height = newSize;
            tileSize = newSize / worldSize;
            drawWorld();
            monsters.forEach(drawMonster);
            npcs.forEach(drawNpc);
            if (player) {
                player.x = Math.max(player.size / 2, Math.min(player.x, newSize - player.size / 2));
                player.y = Math.max(player.size / 2, Math.min(player.y, newSize - player.size / 2));
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'e') {
                const tileX = Math.floor(player.x / tileSize);
                const tileY = Math.floor(player.y / tileSize);
                const tile = getTile(tileX, tileY);
                if (tile && !tile.mined) {
                    mineTile(tileX, tileY);
                }
            }
            if (event.key === 'h') {
                player.health = Math.min(player.health + 20, player.maxHealth);
                updateHealthBar();
                showMessage("Used Health Potion");
            }
             if (event.key === 'f') {
                const tileX = Math.floor(player.x / tileSize);
                const tileY = Math.floor(player.y / tileSize);
                const tile = getTile(tileX, tileY);
                if (tile.type === 'tower') {
                    showMessage("Found the Lost Artifact!");
                    activeQuests.forEach(quest => {
                        if (quest.objective.type === 'find' && quest.artifact === 'Lost Artifact') {
                            quest.found = true;
                        }
                    });
                }
            }
            if (event.key === ' ') {
                event.preventDefault();
                if (player && player.currentAction === 'idle') {
                    interactWithNpc();
                } else if (player && player.currentAction === 'talking') {
                    advanceDialog();
                }
            }
        });

        let lastTime = 0;
        let deltaTime = 0;
        const playerSpeed = 3;

        function updatePlayerPosition() {
            if (!player) return;
            if (keys['ArrowRight'] || keys['d']) {
                player.x += playerSpeed;
                player.direction = 0;
            }
            if (keys['ArrowDown'] || keys['s']) {
                player.y += playerSpeed;
                player.direction = 1;
            }
            if (keys['ArrowLeft'] || keys['a']) {
                player.x -= playerSpeed;
                player.direction = 2;
            }
            if (keys['ArrowUp'] || keys['w']) {
                player.y -= playerSpeed;
                player.direction = 3;
            }

            player.x = Math.max(player.size / 2, Math.min(player.x, canvasSize - player.size / 2));
            player.y = Math.max(player.size / 2, Math.min(player.y, canvasSize - player.size / 2));
        }

        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            const time = performance.now();
            deltaTime = time - lastTime;
            lastTime = time;

            updatePlayerPosition();

            if (player && player.isMining) {
                const tileX = player.miningTarget.x;
                const tileY = player.miningTarget.y;
                const tile = getTile(tileX, tileY);
                if (tile && !tile.mined) {
                    player.miningProgress += deltaTime / tile.hardness;
                    if (player.miningProgress >= 1) {
                        tile.mined = true;
                        if (tile.type === 'stone') {
                            player.inventory["Iron Ore"].quantity++;
                            showMessage("Mined Iron Ore!");
                        }
                        if (tile.type === 'copper') {
                            player.inventory["Copper Ore"].quantity++;
                            showMessage("Mined Copper Ore!");
                        }
                        player.isMining = false;
                        player.miningProgress = 0;
                        updateInventoryDisplay();
                    }
                } else {
                    player.isMining = false;
                    player.miningProgress = 0;
                }
            }

            monsters.forEach(monster => {
                moveMonster(monster);
                monsterAttack(monster);
                handleMonsterAttackCooldown(monster);
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            monsters.forEach(drawMonster);
            npcs.forEach(drawNpc);

            //draw player
            if(player){
                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
            }

            activeQuests.forEach(checkQuestCompletion);
            if(player){
                updateLevel();
                updateHealthBar();
                updateManaBar();
            }
            drawDialog();
        }

        function updateHealthBar() {
            if (!player) return;
            const healthBarFill = document.getElementById('health-bar-fill');
            const healthPercentage = Math.max(0, (player.health / player.maxHealth) * 100);
            healthBarFill.style.width = `${healthPercentage}%`;
            healthBarFill.style.backgroundColor = healthPercentage > 20 ? '#84cc16' : '#ef4444';
            hpText.textContent = `${player.health}/${player.maxHealth}`;
        }

        function updateManaBar() {
            if (!player) return;
            const manaBarFill = document.getElementById('mana-bar-fill');
            const manaPercentage = Math.max(0, (player.mana / player.maxMana) * 100);
            manaBarFill.style.width = `${manaPercentage}%`;
            manaText.textContent = `${player.mana}/${player.maxMana}`;
        }

        function startGame() {
            menuContainer.style.display = 'none';
            charCreationScreen.style.display = 'block';
        }

        function selectClassFunc() {
            if (!charNameInput.value.trim()) {
                showMessage('Please enter a character name.');
                return;
            }
            charCreationScreen.style.display = 'none';
            classSelectionScreen.style.display = 'block';
        }

        function selectClassHandler(event) {
            selectedClass = event.target.dataset.class;
            classSelectionScreen.style.display = 'none';
            skillSelectionScreen.style.display = 'block';
            populateSkillList(selectedClass);
        }

        function populateSkillList(selectedClass) {
            skillList.innerHTML = '';
            const availableSkills = classes[selectedClass].skills;
            availableSkills.forEach(skillName => {
                const skill = allSkills[skillName];
                const li = document.createElement('li');
                li.innerHTML = `<span>${skill.name} - ${skill.description}</span>`;
                const selectButton = document.createElement('button');
                selectButton.textContent = 'Select';
                selectButton.dataset.skill = skillName;
                selectButton.addEventListener('click', () => {
                    toggleSkill(skillName);
                });
                li.appendChild(selectButton);
                skillList.appendChild(li);
            });
        }

        function toggleSkill(skillName) {
            const skill = allSkills[skillName];
             if (selectedSkills.includes(skillName)) {
                selectedSkills = selectedSkills.filter(s => s !== skillName);
                skillPoints++;
            } else if (skillPoints > 0) {
                selectedSkills.push(skillName);
                skillPoints--;
            }

            const selectedButton = skillList.querySelector(`[data-skill="${skillName}"]`);
            if (selectedButton) {
                selectedButton.classList.toggle('selected', selectedSkills.includes(skillName));
            }
            if (skillPoints === 0) {
                 showMessage('You have selected the maximum number of skills.');
            }
        }

        function finishSkillSelection() {
            if (selectedSkills.length !== 5) {
                showMessage('Please select 5 skills.');
                return;
            }
            skillSelectionScreen.style.display = 'none';
            initPlayer();
            generateWorld();
            spawnMonster(canvasSize / 4, canvasSize / 4, 'goblin');
            spawnMonster(canvasSize * 3 / 4, canvasSize / 4, 'orc');
            spawnMonster(canvasSize / 3, canvasSize * 2 / 3, 'goblin');
            spawnMonster(canvasSize / 5, canvasSize / 5, 'skeleton');
            spawnNpc(8, 8, 'villager');
            spawnNpc(20, 20, 'merchant');
            startGameLoop();
            canvas.style.display = 'block';
            inventoryDiv.style.display = 'block';
            questsDiv.style.display = 'block';
        }

        function startGameLoop() {
            if (!gameInitialized) return;
            gameRunning = true;
            lastTime = performance.now();
            animate();
        }

        function loadGame() {
            const savedGame = localStorage.getItem('mineRPGSave');
            if (savedGame) {
                const gameState = JSON.parse(savedGame);
                player = gameState.player;
                tileMap = gameState.tileMap;
                monsters = gameState.monsters;
                activeQuests = gameState.activeQuests;
                selectedClass = gameState.selectedClass;
                npcs = gameState.npcs;
                currentDialog = gameState.currentDialog;

                //fixme
                if(!player.skills){
                    player.skills = [];
                }

                menuContainer.style.display = 'none';
                canvas.style.display = 'block';
                inventoryDiv.style.display = 'block';
                questsDiv.style.display = 'block';
                gameRunning = true;
                lastTime = performance.now();
                animate();
                showMessage('Game loaded!');
            } else {
                showMessage('No saved game found.');
            }
        }

        function saveGame() {
            if (!player) return;
            const gameState = {
                player: player,
                tileMap: tileMap,
                monsters: monsters,
                activeQuests: activeQuests,
                selectedClass: selectedClass,
                npcs: npcs,
                currentDialog: currentDialog,
            };
            localStorage.setItem('mineRPGSave', JSON.stringify(gameState));
            showMessage('Game saved!');
        }


        startGameButton.addEventListener('click', startGame);
        loadGameButton.addEventListener('click', loadGame);
        selectClassButton.addEventListener('click', selectClassFunc);
        classSelectionScreen.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', selectClassHandler);
        });
        finishSkillsButton.addEventListener('click', finishSkillSelection);
        inventoryToggle.addEventListener('click', () => {
            inventoryOpen = !inventoryOpen;
            inventoryDiv.style.display = inventoryOpen ? 'block' : 'none';
            if (inventoryOpen) {
                updateInventoryDisplay();
            }
        });

        questToggle.addEventListener('click', () => {
            questsOpen = !questsOpen;
            questsDiv.style.display = questsOpen ? 'block' : 'none';
            if (questsOpen) {
                updateQuestsDisplay();
            }
        });

        window.addEventListener('beforeunload', (event) => {
            if (gameRunning) {
                saveGame();
                event.preventDefault();
                event.returnValue = 'Do you want to save your game before leaving?';
            }
        });

        // Initial values
        updateInventoryDisplay();
        updateQuestsDisplay();



        // NPC stuff
        function spawnNpc(x, y, type) {
            let npc = {
                id: nextMonsterId++,
                x: x,
                y: y,
                type: type,
                size: 24,
                color: '#b0bec5',
                dialog: null,
                name: type === 'villager' ? 'Villager' : 'Merchant',
                dead: false,
            };
            if (type === 'villager') {
                npc.dialog = {
                    lines: [
                        "Hello there!  Welcome to our town.",
                        "The forest can be dangerous, so be careful!",
                        "You can find some useful items in the shop.",
                    ],
                    currentLine: 0,
                };
            } else if (type === 'merchant') {
                npc.dialog = {
                    lines: [
                        "Welcome to my shop!  I have many wares for sale.",
                        "Take a look at my inventory.  I have potions, weapons, and armor.",
                        "I also buy rare items if you have any to sell.",
                    ],
                    currentLine: 0,
                    itemsForSale: [
                        { name: 'Health Potion', price: 10, quantity: 5 },
                        { name: 'Iron Sword', price: 50, quantity: 1 },
                        { name: 'Leather Armor', price: 40, quantity: 1 },
                    ],
                };
            }
            npcs.push(npc);
        }

        function drawNpc(npc) {
            if(npc.dead) return;
            ctx.fillStyle = npc.color;
            ctx.fillRect(npc.x - npc.size / 2, npc.y - npc.size / 2, npc.size, npc.size);
            ctx.fillStyle = '#ffffff';
            ctx.fillText(npc.name, npc.x - npc.size / 2, npc.y - npc.size / 2 - 5);
        }

        function getClosestNpc() {
            let closestNpc = null;
            let minDistance = Infinity;
            for (const npc of npcs) {
                if(npc.dead) continue;
                const distance = Math.sqrt(Math.pow(player.x - npc.x, 2) + Math.pow(player.y - npc.y, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestNpc = npc;
                }
            }
            return closestNpc;
        }

        function startDialog(npc) {
            if (!player) return;
            currentDialog = npc.dialog;
            player.currentAction = 'talking';
            player.target = npc;
        }

        function drawDialog() {
            if (!currentDialog) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(50, canvasSize - 150, canvasSize - 100, 100);
            ctx.fillStyle = '#ffffff';
            ctx.font = '1rem "Press Start 2P"';
            ctx.fillText(currentDialog.lines[currentDialog.currentLine], 60, canvasSize - 120, canvasSize - 120);
        }

        function advanceDialog() {
            if (!currentDialog) return;

            currentDialog.currentLine++;
            if (currentDialog.currentLine >= currentDialog.lines.length) {
                currentDialog = null;
                player.currentAction = 'idle';
                player.target = null;
            }
        }

        function interactWithNpc() {
            if (!player) return;
            const closestNpc = getClosestNpc();
            if (closestNpc && Math.sqrt(Math.pow(player.x - closestNpc.x, 2) + Math.pow(player.y - closestNpc.y, 2)) < tileSize) {
                if (player.currentAction === 'idle') {
                    startDialog(closestNpc);
                } else if (player.currentAction === 'talking') {
                    advanceDialog();
                }
            }
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === ' ') {
                event.preventDefault();
                if (player && player.currentAction === 'idle') {
                    interactWithNpc();
                } else if (player && player.currentAction === 'talking') {
                    advanceDialog();
                }
            }
        });

        // Load images
        Promise.all(Object.values(tileImages).map(img => {
            return new Promise(resolve => {
                img.onload = () => resolve();
                img.onerror = () => {
                    console.error(`Failed to load image: ${img.src}`);
                    resolve();
                };
            });
        })).then(() => {
            // All images are loaded, start the game
            if(gameRunning) {
                animate();
            }
        });

        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            const time = performance.now();
            deltaTime = time - lastTime;
            lastTime = time;

            updatePlayerPosition();

            if (player && player.isMining) {
                const tileX = player.miningTarget.x;
                const tileY = player.miningTarget.y;
                const tile = getTile(tileX, tileY);
                if (tile && !tile.mined) {
                    player.miningProgress += deltaTime / tile.hardness;
                    if (player.miningProgress >= 1) {
                        tile.mined = true;
                        if (tile.type === 'stone') {
                            player.inventory["Iron Ore"].quantity++;
                            showMessage("Mined Iron Ore!");
                        }
                        if (tile.type === 'copper') {
                            player.inventory["Copper Ore"].quantity++;
                            showMessage("Mined Copper Ore!");
                        }
                        player.isMining = false;
                        player.miningProgress = 0;
                        updateInventoryDisplay();
                    }
                } else {
                    player.isMining = false;
                    player.miningProgress = 0;
                }
            }

            monsters.forEach(monster => {
                moveMonster(monster);
                monsterAttack(monster);
                handleMonsterAttackCooldown(monster);
            });

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawWorld();
            monsters.forEach(drawMonster);
            npcs.forEach(drawNpc);

            //draw player
            if(player){
                ctx.fillStyle = '#007bff';
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
            }

            activeQuests.forEach(checkQuestCompletion);
            if(player){
                updateLevel();
                updateHealthBar();
                updateManaBar();
            }
            drawDialog();
        }

    </script>
</body>
</html>
